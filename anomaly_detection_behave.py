# -*- coding: utf-8 -*-
"""Copy of Copy of Anomaly_detection_ucf.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16H83Yh2aFXqJE4HYXsGuA9z1py7AkBeA
"""

from pydrive.auth import GoogleAuth
from pydrive.drive import GoogleDrive
from google.colab import auth
from oauth2client.client import GoogleCredentials

auth.authenticate_user()
gauth = GoogleAuth()
gauth.credentials = GoogleCredentials.get_application_default()
drive = GoogleDrive(gauth)

link="https://drive.google.com/open?id=1clpOr6-Q5y6EZA7EicW2FSrvJQbKbpiF"
fluff, id = link.split('=')
downloaded = drive.CreateFile({'id':id}) 
downloaded.GetContentFile('data.zip')

!unzip ./data.zip
!mv ./ucf\ anaomaly\ detection/* ./
!rm -r ./ucf\ anaomaly\ detection

import os
from c3d import preprocess_input,C3D,c3d_feature_extractor
from classifier import classifier_model,conv_dict,build_classifier_model,load_weights
from keras.utils.vis_utils import *
from utils.video_util import *
from utils.array_util import *
import glob
import  configuration as cfg
from tqdm import tqdm

def generatedata(path,feature_extractor):
    x_train=[]
    y_train=[]
    for video_file in tqdm(glob.glob(path)):
        video_name = os.path.basename(video_file).split('.')[0]
        if video_name[0:6] == "Normal":
            y_train.append(0)
        else:
            y_train.append(1)
        video_clips, num_frames = get_video_clips(video_file)  
        rgb_features = []
        for i, clip in enumerate(video_clips):
            clip = np.array(clip)
            if len(clip) < params.frame_count:
                continue
            clip = preprocess_input(clip)
            rgb_feature = feature_extractor.predict(clip)[0]
            rgb_features.append(rgb_feature)
    
        rgb_features = np.array(rgb_features)
    
        rgb_feature_bag = interpolate(rgb_features, params.features_per_bag)
        x_train.append(rgb_feature_bag)
    return np.array(x_train),y_train

feature_extractor = c3d_feature_extractor()

x_train,y_train=generatedata('./training/*.mp4',feature_extractor)

from keras import backend as K
def recall_m(y_true, y_pred):
        true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))
        possible_positives = K.sum(K.round(K.clip(y_true, 0, 1)))
        recall = true_positives / (possible_positives + K.epsilon())
        return recall

def precision_m(y_true, y_pred):
        true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))
        predicted_positives = K.sum(K.round(K.clip(y_pred, 0, 1)))
        precision = true_positives / (predicted_positives + K.epsilon())
        return precision

def f1_m(y_true, y_pred):
    precision = precision_m(y_true, y_pred)
    recall = recall_m(y_true, y_pred)
    return 2*((precision*recall)/(precision+recall+K.epsilon()))

from keras import Sequential
from keras.layers import Dense, Dropout,LSTM
from keras.regularizers import l2

def classifier_model():
    model = Sequential()
    model.add(LSTM(512, input_dim=4096, kernel_initializer='glorot_normal', kernel_regularizer=l2(0.01), activation='relu'))
    model.add(Dropout(0.6))
    model.add(Dense(64, kernel_initializer='glorot_normal', kernel_regularizer=l2(0.01), activation='sigmoid'))
    model.add(Dropout(0.6))
    model.add(Dense(32, kernel_initializer='glorot_normal', kernel_regularizer=l2(0.01)))
    model.add(Dropout(0.6))
    model.add(Dense(1, kernel_initializer='glorot_normal', kernel_regularizer=l2(0.01), activation='sigmoid'))
   
    return model

model=classifier_model()
model.summary()
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy',f1_m])
model.fit(x_train,y_train,epochs=100)

model.save_weights("model.h5")



"""###Testing the model"""

model=build_classifier_model()

import os
from c3d import preprocess_input,C3D,c3d_feature_extractor
from classifier import classifier_model ,conv_dict,build_classifier_model,load_weights
import glob
import  configuration as cfg
from utils.video_util import *
from utils.array_util import *
import cv2

def run_demo():
    sample_video_path = './testing/*.mp4'
    # read video
    score_TT = 0
    score_TF = 0
    score_FF = 0
    score_FT = 0
    step = 0
    real_n = 0
    real_a = 0
    
    for video_file in glob.glob(sample_video_path):
        step += 1
        print("\nStep : ",step)
        video_name = os.path.basename(video_file).split('.')[0]
        print("Video_name : ",video_name)
        if video_name[0:6] == "Normal":
            real_n += 1
        else:
            real_a += 1
        video_clips, num_frames = get_video_clips(video_file)
    
        print("Number of clips in the video : ", len(video_clips))
        
        rgb_features = []
        print("\tprocessing clip ...")
        for i, clip in enumerate(video_clips):
            clip = np.array(clip)
            if len(clip) < params.frame_count:
                continue
    
            clip = preprocess_input(clip)
            rgb_feature = feature_extractor.predict(clip)[0]
            rgb_features.append(rgb_feature)
    
        rgb_features = np.array(rgb_features)
    
        # bag features
        rgb_feature_bag = interpolate(rgb_features, params.features_per_bag)
    
        # classify using the trained classifier model
        leng,widt=rgb_feature_bag.shape
        predictions = model.predict(rgb_feature_bag.reshape(1,leng,widt))
        predictions = np.array(predictions).squeeze()
        if predictions> 0.5:
            print("*** anomaly video ***")
            if video_name[0:6] == "Normal":
                score_TF += 1
            else:
                score_FF += 1
        else:
            if video_name[0:6] == "Normal":
                score_TT += 1
            else:
                score_FT += 1
            print(' ** Normal video ** ')
    print("Number of Video files = ",step)
    print("Number of Actual-Normal-Videos = ",real_n,"Number of Predicted Normal Videos = ",score_TT + score_FT)
    print("Number of Actual-Anomaly Videos = ",real_a,"Number of Predicted Anomaly Videos = ",score_TF + score_FF)
    print(" ** Accuaracy of Prediction ** ")
    if real_n!=0:
        print(" TT = ",round(score_TT/real_n,2),"TF = ",round(score_TF/real_n,2))
    if real_a!=0:
        print(" FT = ",round(score_FT/real_a,2),"FF = ",round(score_FF/real_a,2))
    Accuracy = (score_TT + score_FF)/(score_TT+ score_TF+ score_FT+ score_FF)
    print("Accuracy = ",Accuracy)


if __name__ == '__main__':
    run_demo()

